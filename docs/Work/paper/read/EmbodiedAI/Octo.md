# Octo——机器人操控的通用框架

[Octo](https://arxiv.org/pdf/2405.12213)

机器人学习领域长期面临一项核心挑战：如何开发出能够跨越不同任务、环境和机器人形态（embodiment）进行泛化的策略，而不是为每个新场景从头训练专门的策略 。传统方法通常需要为每个任务收集大量数据，且最终得到的策略泛化能力有限 。

针对这些局限性，Octo 被提出作为一个开源的通用机器人策略（Generalist Robot Policy, GRP）。它基于从 Open X-Embodiment 数据集中精心挑选的 80 万条多样化机器人轨迹进行了预训练，并具备向新的机器人设置、传感器和动作空间高效微调的能力 。Octo 旨在作为一种通用的策略初始化方案，为各种下游机器人应用提供支持 。

Octo 的主要贡献在于：它是首个能够有效微调以适应新观测和动作空间的 GRP，并且是首个完全开源的通用机器人操控策略，包括训练流程、模型检查点和数据 。本报告将对 Octo 的架构、训练方法、数据处理、微调机制以及关键设计选择进行深入的技术剖析，重点阐述支撑其功能的原理和实现细节。

以往的大型通用模型往往不向公众开放 ，这极大地阻碍了可复现性和社区驱动的研究进展。Octo 的开发团队通过将所有组件——包括预训练检查点、微调脚本、预训练流程和数据加载器——完全开源 ，不仅仅是发布了一个模型，更提供了一个平台。这种开放性显著降低了研究人员在通用机器人策略领域进行构建、实验和验证的门槛。特别是明确提供了“监控训练进度的工具”和“优化的数据加载器” ，进一步支持了这一目标。因此，Octo 的开源特性是一项战略性决策，旨在通过构建一个协作的研究生态系统来加速通用机器人策略领域的发展，摆脱了以往封闭模型的局限性，并普及了大规模机器人学习工具的使用。

## 1. 架构深度剖析：Octo 模型

Octo 模型的核心是一个基于 Transformer 的策略，其设计强调灵活性和可扩展性，使其能够处理多样化的输入并适应不同的机器人硬件。

### 1.1 输入模态处理与符号化（Tokenization）
Octo 的通用能力始于其将异构输入（如语言指令和图像观测）转换为统一的符号序列（token sequence）的过程，这是 Transformer 模型处理的前提 。

#### 1.1.1 语言指令编码
自然语言指令首先被符号化，然后通过一个预训练的 t5-base Transformer 模型（包含 1.11 亿参数）进行处理 。该模型输出一个包含 16 个语言嵌入符号的序列 。利用像 T5 这样强大的预训练语言模型，Octo 能够从大规模文本语料库中学习到的丰富语义理解中受益，从而更好地解释自然语言命令。

#### 1.1.2 视觉观测处理
图像观测（例如，腕部和第三方摄像头的图像流）和目标图像会经过一个浅层卷积神经网络（CNN）堆栈 。随后，输出被分割成一系列扁平化的图像块（patches），例如 16×16 像素的图像块 。对于第三方摄像头图像（调整大小至 256×256），这会产生 256 个符号；对于腕部摄像头图像（调整大小至 128×128），则产生 64 个符号 。这种“浅层CNN”后接图像块化的方法是视觉 Transformer（ViT）架构的典型特征，与在其他模型中用作主要特征提取器的深层 CNN（如 ResNet）形成对比。这一选择与 Octo 的“Transformer优先”设计理念相符 。

采用浅层 CNN 意味着大部分复杂的特征提取和关系理解任务被交给了后续的 Transformer 主干网络。这符合 ViT 的理念，即 Transformer 本身从图像块中学习视觉特征。将图像块大小从 32×32 减小到 16×16 被发现可以提高模型在精细操作任务（如抓取）上的性能，因为它为 Transformer 提供了更高分辨率的输入，使其能够捕捉对精确操控至关重要的更精细细节 。然而，更小的图像块意味着 Transformer 需要处理更长的符号序列（例如，256×256 的图像使用 16×16 的图像块会产生 256 个符号，而使用 32×32 的图像块则为 64 个符号）。由于 Transformer 的计算复杂度与序列长度成二次方关系，这无疑增加了计算负担，论文中也承认这增加了“计算复杂度” 。这一设计反映了一种深思熟虑的权衡：优先考虑视觉敏锐度以实现操控精度，代价是增加 Transformer 的计算负荷。这表明，对于目标操控任务而言，详细视觉输入带来的好处超过了计算开销，这一决策很可能得到了实证结果的支持（例如，ViT 架构在实验中表现良好）。

#### 1.1.3 任务与观测符号的组装
可学习的位置嵌入（positional embeddings）被添加到任务符号（来自语言指令或目标图像）和观测符号中。然后，这些符号按顺序排列，例如 $T_L, T_G, O_{0,w}, O_{0,h}, \dots, O_{H-1,w}, O_{H-1,h}$，形成 Transformer 主干网络的输入序列 。位置嵌入对于 Transformer 理解序列中符号的顺序和关系至关重要，因为自注意力机制本身是排列不变的。

### 1.2 Transformer 主干网络：策略的核心
Octo 的中央处理单元是一个 Transformer 主干网络，其设计借鉴了 ViT 的原则，负责处理统一的符号序列 。

#### 1.2.1 源自视觉 Transformer (ViT) 的设计理念
Octo 采用“Transformer优先”的架构，大部分参数和浮点运算（FLOPs）集中在 Transformer 主干网络中，而不是大型的上游 CNN 编码器 。这与经典的 ViT 架构相似 。Octo 提供了两种主要变体（详见表1）：Octo-Small（12层，384隐藏层大小，6个注意力头，2700万参数）和 Octo-Base（12层，768隐藏层大小，12个注意力头，9300万参数）。这种设计选择基于 Transformer 的可扩展性以及它们在处理大规模多样化数据集时直接从最少处理的输入（图像块）中学习强大表征的能力。

**表1: Octo 模型架构变体**

| 模型        | 层数 | 隐藏层大小 D | MLP 大小 | 注意力头数 | 参数量 |
| :---------- | :--- | :----------- | :------- | :--------- | :----- |
| Octo-Small  | 12   | 384          | 1536     | 6          | 27M    |
| Octo-Base   | 12   | 768          | 3072     | 12         | 93M    |



明确列出这些架构参数不仅提供了基础技术信息，满足了对技术细节的深度要求，而且通过比较 Octo-Small 和 Octo-Base 的参数，突显了模型规模化的方面。这为希望理解模型复杂度或复现类似架构的研究人员提供了具体的数字。

#### 1.2.2 实现灵活性的分块掩码注意力机制
Octo Transformer 的注意力模式采用分块掩码（block-wise masked）方式。观测符号只能因果地（causally）关注来自相同或更早时间步长 ($T_{o.0:t}$)的符号以及任务符号($T_T$) 。对应于不存在的输入（例如，某个数据样本没有语言指令）的符号则被完全掩码掉 。这种模块化设计对 Octo 的灵活性至关重要。它使得模型能够：1) 处理异构数据集，其中并非所有模态都始终存在（例如，一些数据有语言指令，一些则没有）。2) 在微调过程中添加或删除输入/输出模态，而无需修改核心主干网络的预训练参数 。

一个“通用”机器人策略必须能够处理在各种真实世界场景或数据集中遇到的不同传感器套件和任务规范。对所有可以想象到的组合进行预训练是不可行的。分块掩码注意力以及掩码掉不存在输入的能力，使得单个预训练模型能够优雅地处理缺少模态的数据（例如，一些轨迹有腕部摄像头，另一些则没有；一些有语言指令，另一些则没有）。至关重要的是，这种能力延伸到了微调阶段：如果一个新任务需要新的传感器类型（例如，“Berkeley Insertion”任务中的力-力矩传感器 ）或新的动作空间（例如，“Berkeley Pick-Up”任务中的关节控制 ），可以添加新的轻量级编码器或动作头，并为这些新符号学习新的位置嵌入，而核心的、参数众多的 Transformer 主干网络则保持不变，并利用其预训练知识。这与先前的架构形成了鲜明对比，在那些架构中，“添加或删除图像输入或更改任务规范将需要重新初始化或重新训练预训练模型的大部分组件” 。因此，这种架构模块化不仅仅是一种便利，更是 Octo 声称的通用性和高效微调能力的基础推动因素。它使模型能够成为一个真正适应性强的基础，而不是一个僵化的、固定输入/输出的系统。

#### 1.2.3 用于生成与动作相关嵌入的读出符号
学习到的“读出符号”（readout tokens, $T_{R,t}$）被插入到序列中。这些符号会关注序列中位于它们之前的观测和任务符号，但它们自身不会被其他观测或任务符号所关注。它们的功能是主动读取和聚合信息 。类似于 BERT 中的 `[CLS]` 符号，读出符号作为紧凑的向量嵌入，代表了到时间 t 为止观测序列的处理状态。这些嵌入随后被传递给动作头 。这种设计提供了一种专门的机制，用于从 Transformer 的内部表征中汇集与动作解码特别相关的信息，将此与一般的序列处理分离开来。

### 1.3 通过条件扩散生成动作
本节将解释 Octo 如何将来自 Transformer 的处理后表征转换为机器人动作，重点是其采用的扩散模型 。

#### 1.3.1 用于动作解码的去噪扩散概率模型 (DDPM)
Octo 采用条件扩散解码头（conditional diffusion decoding head）来预测连续的、多模态的动作分布 。该方法使用 Ho 等人 (2020) 提出的标准 DDPM 目标进行训练 。选择扩散模型是因为它们能够建模复杂的、潜在多模态的分布（这对于存在多种有效动作的任务非常重要），并能生成高保真度的连续输出（这对于精确的机器人控制至关重要）。这种方法优于均方误差（MSE）损失（容易产生“折衷”或平均化多模态输出）和离散化动作头（会损失精度）。

#### 1.3.2 多步去噪过程与噪声调度 (公式1)

- 动作生成过程包括首先采样一个高斯噪声向量 $x^K \sim \mathcal{N}(0,I)$

- 然后使用一个学习到的去噪网络 $\epsilon_{\theta}(x^k,e,k)$ 在 K 个步骤中迭代地对其进行优化 。

- 该网络以先前的噪声动作 $x^k$、当前的去噪步骤 $k$ 以及来自 Transformer 读出符号的嵌入 $e$ 作为条件 。去噪步骤由以下公式给出：

$$x^{k-1} = \alpha(x^k - \gamma\epsilon_{\theta}(x^k,e,k) + \mathcal{N}(0,\sigma^2I))$$

其中，$\alpha, \gamma, \sigma$ 是定义噪声调度表的超参数 。Octo 使用标准的余弦噪声调度表（Nichol & Dhariwal, 2021），并指定了 20 个扩散步骤（即 $K=20$）。扩散动作头本身是一个 3 层的 MLP，隐藏维度为 256，带有残差连接和层归一化 。

#### 1.3.3 动作块（Action Chunks）的预测
动作头并非在每个时间步预测单个动作，而是预测一个包含未来几个连续动作的“块”（chunk）。实验发现，预测动作块有助于生成更连贯和平滑的策略运动 ，这可以改善时间上的一致性并减少急动。

Transformer 主干网络是 Octo 模型中计算量最大的部分（例如 ViT-Base 有 9300 万参数）。扩散模型需要一个迭代的去噪过程（论文中提到 $K=20$ 步）。如果整个 Transformer 都需要在每个去噪步骤中运行，那么生成单个动作（或动作块）的推理时间对于实时机器人控制来说将过高。通过仅执行一次 Transformer 前向传播以获得条件嵌入 $e$，然后在“小型扩散头”（一个 3 层 MLP）内运行 K 个去噪步骤，显著降低了动作生成的计算成本 。这种设计有效地将理解场景和历史的复杂任务（由大型 Transformer 处理）与优化动作分布的迭代过程（由轻量级扩散头处理）解耦。这一架构选择对于使强大的扩散模型在机器人控制中变得实用至关重要，它平衡了扩散模型的表达能力与机器人应用的计算约束，使得 Octo 能够在不产生过高推理成本的情况下利用扩散模型的高质量动作生成能力。

### 1.4 面向可扩展性与微调的架构设计
Octo 的架构设计核心在于其模块化特性，这使得模型不仅能够处理预训练阶段的异构数据，还能在后续针对新任务或机器人进行微调时展现出高度的灵活性和效率。输入符号化过程的灵活性（例如，对未使用的输入进行掩码，以及为新传感器添加新的轻量级编码器）、Transformer 内部的分块掩码注意力机制，以及附加新动作头的能力，共同构成了 Octo 适应性的基础 。

具体而言，当针对具有不同传感器或动作空间的新任务或机器人进行微调时，核心的预训练 Transformer 权重可以在很大程度上得到保留 。对于新的传感器模态（例如，“Berkeley Insertion”任务中的力-力矩传感器 ），可以添加一个新的轻量级编码器，并为这些新符号学习新的位置嵌入 。对于新的动作空间（例如，“Berkeley Pick-Up”任务中的关节位置控制 ，或“Berkeley Bimanual”任务中的双臂控制 ），则可以添加一个新的动作头（例如，新的扩散头或 MLP），或者重新初始化并训练一个现有的动作头 。这种方法最大限度地减少了需要为新任务从头学习的参数数量，充分利用了在预训练阶段学习到的丰富表征。这与以往的架构形成了鲜明对比，在那些架构中，“添加或删除图像输入或更改任务规范将需要重新初始化或重新训练预训练模型的大部分组件” 。

在微调过程中，Octo 采用与预训练相同的扩散训练目标，并更新整个模型，而不是冻结部分预训练参数。实验表明，这种“全模型更新”的策略优于那些冻结部分预训练参数的方法 。尽管微调通常在数据量相对较小的目标域数据集上进行（例如约 100 条轨迹 ），但更新整个模型似乎能带来更好的性能。这表明，对于机器人策略而言，即使有强大的预训练初始化，允许整个网络适应新领域的细微差别（如新的动力学特性、新的视觉特征、新的任务目标）也是有益的。这可能是因为预训练权重起到了强正则化作用，或者扩散目标的特性使得模型能够在少量数据下有效调整，而不会发生灾难性遗忘。这一发现对迁移学习中的一个常见启发式方法提出了挑战，即在目标数据有限时冻结主干网络（特征提取器）并仅训练最后几层或新添加的头部。Octo 的经验表明，对于像它这样复杂的视觉运动策略，端到端微调，即使在小型数据集上，也可能优于部分冻结。这或许是因为机器人任务需要感知、状态表征和动作生成之间的高度耦合，协同调整所有部分更为有效。

# 2. 数据基础与预训练方法论
Octo 的通用能力在很大程度上源于其训练数据的规模和多样性，以及精心设计的预训练流程。

### 2.1 Open X-Embodiment 数据集：规模与多样性
本节详细介绍用于预训练 Octo 的数据，这是其通用能力的核心基石。

#### 2.1.1 数据筛选：选择标准与理由
Octo 在从 Open X-Embodiment (OXE) 数据集中筛选出的 80 万条机器人轨迹上进行训练，而 OXE 数据集本身包含约 150 万个片段。这使得 Octo 成为迄今为止用于训练此类模型的最大规模的机器人操控演示数据集 。其训练混合数据包含来自 25 个不同数据集的数据 。筛选标准包括：

-   排除不包含图像流的数据集。
-   排除不使用差分末端执行器控制（delta end-effector control）的数据集。
-   移除被认为过于重复、图像分辨率低或专注于过于小众任务的数据集 。

这些筛选旨在创建一个高质量、多样化的数据集，专注于视觉运动控制的操控任务，确保数据在一定程度上的一致性（例如，图像的存在、通用的动作类型），同时最大化行为多样性。

#### 2.1.2 数据集混合与采样权重 

这些数据集在机器人类型、传感器（例如，是否包含腕部摄像头）和标签（例如，是否包含语言指令）方面具有异构性 。数据集的采样权重主要由其规模决定，但进行了一些调整：根据任务和环境被分类为“更多样化”的数据集，其权重在训练中被加倍；而一些大型但重复性高的数据集则被降权，以避免其在混合数据中占据主导地位 。附录 C（表 III）提供了详细的混合比例 。这种加权策略试图在较大数据集的纯粹数据量与从较小但更多样化的数据集中学习广泛行为和场景的需求之间取得平衡。

#### 2.1.3 数据预处理

-   **缺失模态处理**：缺失的摄像头通道用零填充 。如果在数据样本中不存在语言指令或目标图像，或者为了增强模型的鲁棒性，它们会在训练过程中被随机置零 。
-   **夹爪动作对齐**：对不同数据集间的夹爪动作空间进行对齐，统一规定+1表示“夹爪张开”，-1表示“夹爪闭合” 。论文在附录E中提到，尽管“相对”夹爪表示在某些情况下能略微提高抓取成功率，但最终选择了“绝对”夹爪表示，因为它在发生抓取失败后的重试行为上表现更好 。
-   **打乱缓冲区 (Shuffle Buffer)**：使用了一个高达 50 万帧的大型打乱缓冲区，在图像解码之前进行帧级别的打乱和不同轨迹间的交错混合，这对于提升零样本性能至关重要 。为了避免单个过长片段“挤占”打乱缓冲区，每个训练轨迹最多只随机采样 100 个步骤 。

Open X-Embodiment 数据集虽然庞大，但它是由许多不同的数据集汇集而成，每个数据集都有其自身的约定、硬件和标注质量。这种异构性既是优势（多样性），也是挑战（一致性）。诸如零填充缺失通道、对齐夹爪动作、随机置零任务规范以及仔细管理数据打乱和加权等预处理步骤，是实用的工程解决方案，旨在将这些多样化的数据源协调成单个模型可以消化的格式。加权策略和精心的打乱不仅仅关乎数据量，更重要的是确保模型学习到均衡的表征，并且不会因少数主导数据集或过长且信息量不足的轨迹片段的特异性而产生过度偏倚。大型且管理良好的打乱缓冲区对零样本性能有显著影响这一发现，凸显了这些大型模型对训练期间数据呈现方式的敏感性。因此，在大型聚合数据集上训练通用机器人策略，需要在数据筛选、预处理和策略性采样方面付出巨大努力。现实世界机器人数据的“混乱性”要求稳健且周到的数据处理流程；仅仅向问题投入更多数据而没有这些考虑是不足的。Octo 的成功部分归功于这些细致但可能不那么引人注目的数据工程工作。

### 2.2 训练目标与优化策略
本节涵盖用于预训练 Octo 的损失函数和优化细节。

#### 2.2.1 条件扩散损失
去噪网络 $\epsilon_{\theta}(x^k,e,k)$ 使用标准的 DDPM 目标（Ho et al., 2020）进行训练。该目标包括向数据集中的动作添加高斯噪声，然后训练网络以重建原始动作，训练过程以 Transformer 嵌入 $e$ 和噪声水平 $k$ 为条件 。

#### 2.2.2 关键超参数与训练方案 (表IV, 附录D)
Octo 的预训练采用了一系列精心选择的超参数和优化策略，这些参数对于训练大型 Transformer 模型至关重要，并反映了该领域的最佳实践。具体参数见表2。

**表2: Octo 模型关键预训练超参数**

| 超参数           | 值                  |
| :--------------- | :------------------ |
| 学习率           | 3e-4                |
| 预热步数         | 2000                |
| 学习率调度器     | reciprocal square-root |
| 权重衰减         | 0.1                 |
| 梯度裁剪阈值     | 1                   |
| 批量大小         | 2048                |
*来源: 2405.12213v2.pdf Table IV*

Octo-Base 模型在这些设置下训练了 30 万步 。提供这些超参数对于希望复现或在此工作基础上进行构建的研究人员至关重要，直接支持了对技术细节的深入要求。

#### 2.2.3 观测历史、事后经验重播与数据增强
-   **观测历史**：模型训练时使用 2 帧的观测历史。实验表明，增加一帧历史记录可以改善零样本评估的性能；但在初步测试中，继续增加历史帧数带来的收益递减 。
-   **事后经验重播 (Hindsight Goal Relabeling, HGR)**：从轨迹的未来部分均匀选择一个状态作为目标图像。这种技术可以扩充目标条件下的数据 。
-   **数据增强**：应用了标准的图像数据增强方法：对于第三方摄像头图像，进行随机裁剪、调整大小、色彩抖动；对于腕部摄像头图像，采用类似流程，但不进行裁剪，并调整至不同大小。像素值被归一化到 [-1, 1] 区间 。如果数据未标注语言指令或目标图像，或者为了增强鲁棒性，这些任务输入会按样本随机置零 。

诸如使用 2 帧历史、HGR、特定的图像增强、任务输入的随机置零以及打乱缓冲区大小的显著影响等，这些并非核心架构选择，而是训练过程和数据呈现方面的细节 。一帧历史记录能提升性能的事实表明，即使是最小的时间上下文，也有助于策略推断动态或意图。HGR 是一种成熟的技术，可以提高目标条件任务的样本效率，有效地从现有轨迹中创造更多成功示例。图像增强帮助模型泛化到光照、物体位置和相机视角的各种变化。随机置零任务输入迫使模型对信息缺失具有鲁棒性，并可能学会在一种模态缺失时从上下文中推断任务或依赖其他模态，这对于处理异构的预训练数据至关重要（其中只有 56% 的数据包含语言标注 ）。关于打乱缓冲区的细节  表明，即使是数据如何混合和按批次呈现，也会对最终模型的零样本泛化产生不可忽视的影响。因此，在大规模机器人学习中实现顶尖性能，不仅仅取决于新颖的架构或海量数据；它还依赖于对训练过程的细致调整，包括数据如何增强、排序和呈现给模型。这些“细节”共同对鲁棒性和泛化能力做出了重大贡献。

### 2.3 训练基础设施与模型变体
#### 2.3.1 Octo-Small 与 Octo-Base：参数化 (表V)

如第 1.2.1 节所述，Octo 提供了 Octo-Small (27M 参数) 和 Octo-Base (93M 参数) 两种规模的预训练模型 。这两种变体的详细参数已在表1中列出，在此不再赘述，但强调了模型规模是评估的一个维度。

#### 2.3.2 计算资源 (TPU v4-128) 与训练时长
Octo-Base 模型在一个 TPU v4-128 Pod 上进行训练 。在批量大小为 2048 的情况下，预训练 30 万步耗时 14 小时 。模型使用 JAX 实现，并提供了与 JAX 和 PyTorch 兼容的数据加载器 。明确说明硬件和训练时间为其他研究人员规划类似实验时提供了关于计算预算的背景信息。

# 3. 高效适应：针对新领域的 Octo 微调
Octo 的一个核心优势在于其能够高效地适应新的机器人任务和环境。

### 3.1 迁移与适应机制

如第 1.4 节所讨论，Octo 在微调时会很大程度上保留预训练的 Transformer 主干网络权重，这些权重作为强大的初始化基础 。针对新的观测输入（例如，“Berkeley Insertion”任务中的力-力矩传感器 ），可以添加一个新的轻量级编码器，并为这些新的输入符号学习相应的位置嵌入 。对于新的动作空间（例如，“Berkeley Pick-Up”任务中的关节位置控制 ，或“Berkeley Bimanual”任务中的双臂机器人14维动作空间 ），则可以添加一个新的动作头（例如，新的扩散头或MLP），或者重新初始化并训练一个现有的动作头 。这种方法旨在最大限度地减少需要为新任务从头学习的参数数量，充分利用在预训练阶段学习到的丰富表征。

### 3.2 标准化微调协议

Octo 的微调遵循一个标准化的流程，该流程在所有评估任务中保持一致，使其成为一个可靠的默认配置：

-   **数据需求**：通常需要约 100 条领域内演示轨迹 。
-   **优化步骤**：模型微调 5 万步 。
-   **学习率调度**：采用带有线性预热的余弦衰减学习率调度 。
-   **计算成本**：在单个 NVIDIA A5000 GPU (24GB VRAM) 上大约需要 5 小时 。
-   **全模型更新策略**：在微调过程中更新整个模型，而不仅仅是新添加的组件或最后几层。实验发现这种方法优于冻结部分参数的策略 。

Octo 通过在仅约 100 条轨迹上进行 5 万步微调，即可在新任务和机器人上取得强大性能，显著优于从零开始训练或使用如 VC-1 等预训练视觉表征的方法 。为每个新机器人或任务收集大规模数据集是机器人领域的主要瓶颈。在约 100 条轨迹上从零开始训练像 Transformer 这样的复杂策略通常会导致严重的过拟合（正如其从零开始的基线实验所指出的 ）。Octo 的预训练提供了一个鲁棒的初始化，它规范了微调过程，并允许从稀疏数据中学习。与从零开始训练相比，性能的大幅提升（例如，Octo 的平均成功率为 72%，而 ResNet+Transformer 从零训练的成功率为 20% ）证明了预训练的巨大价值。能够在消费级 GPU 上几小时内完成这一过程，使其具有高度实用性。这种微调方案在 9 种不同设置中的一致性进一步强调了其鲁棒性 。因此，Octo 的微调方案通过大幅降低在新机器人/任务上部署有效策略所需的数据和计算需求，达到了一个实用的“最佳平衡点”。这显著降低了在多样化机器人环境中应用先进学习技术的门槛，这也是通用机器人策略的核心目标。

# 4. 关键设计原则与实证验证
Octo 的性能并非偶然，而是源于一系列关键的设计决策和通过大量实验验证的实现细节。本节综合了论文第四部分C节和附录E中的核心发现。

**表3: Octo 关键设计选择及其性能影响总结**

| 设计维度       | Octo 选择与对比方案                                  | 在 WidowX 上的性能 (Octo-Small) | 来源 (2405.12213v2.pdf) |
| :------------- | :----------------------------------------------------- | :------------------------------ | :---------------------- |
| 架构           | ViT (Octo) vs. ResNet-50 + Transformer                 | 83% vs. 70%                     | Table II                |
| 动作头         | 扩散 vs. 连续MSE vs. 离散化                            | 83% vs. 35% (MSE) vs. 18% (离散) | Table II                |
| 训练数据       | Octo 混合 vs. RT-X 混合 vs. 单机器人数据 (Bridge)      | 83% vs. 60% vs. 43%             | Table II                |
| 图像块大小     | 16×16 (定性提升精细任务性能)                           | N/A (定性)                      | Appendix E.1            |
| 动作分块       | 采用 (有助于运动连贯性)                                | N/A (定性)                      | Appendix E.1            |
| 历史信息       | 1 帧历史 (改善零样本性能)                              | N/A (定性)                      | Appendix E.1            |
| 打乱缓冲区     | 大型且管理良好 (对零样本性能至关重要)                  | N/A (定性)                      | Appendix E.1            |

注：N/A 表示该项为定性描述或未在Table II中直接量化比较。

### 4.1 架构选择的影响
**Transformer优先 (ViT) vs. CNN优先 (ResNet) 编码器：**
Octo 采用的 ViT 风格架构在完整且多样化的 Open X-Embodiment 数据集混合上训练时，性能显著优于基于 ResNet 的编码器 。然而，当在小型数据集上从零开始训练时，ResNet 架构表现更好 。这突出表明最优架构可能依赖于数据。大型 Transformer 在拥有海量多样化数据集时表现出色，而 ResNet 可能对较小、更集中的数据具有更好的归纳偏置。

**图像块大小 (16×16 vs. 32×32)：**

使用 16×16 的图像块，尽管计算成本更高，但改善了精细任务的性能 。这表明，为 Transformer 提供更高分辨率的输入有助于提高操控的精度。

### 4.2 训练数据与目标的效能

**数据混合广度的影响：**

随着训练数据集数量的增加，模型性能也随之提升（Octo 混合数据 > RT-X 混合数据 > 单一数据集）。这表明在预训练期间接触更广泛的任务、机器人和环境，可以带来更好的泛化能力和更强大的基础模型。

**扩散 vs. MSE vs. 离散化动作预测：**

扩散解码在性能上显著优于 MSE（导致策略行动缓慢、“折衷”）和离散化动作（不精确、常导致抓取失败）。扩散模型有效地建模了多模态动作分布，同时保持了连续动作的精度，这对于果断且准确的操控至关重要。

### 4.3 模型规模的益处 

零样本性能随着模型规模的增加而提升（Base > Small > Tiny）。Octo-Base (93M 参数) 比 Octo-Small (27M 参数) 对初始场景配置更鲁棒，并且更少出现过早尝试抓取的行为，这表明更大的模型具有更好的视觉场景感知能力 。这说明了大型模型拥有更大的容量从多样化数据中学习复杂关系，从而带来改进的感知和更鲁棒的行为。

### 4.4 关键实施洞察 

**有效策略：**

-   **历史信息**：一帧的观测历史改善了零样本评估结果 。
-   **动作分块 (Action Chunking)**：有助于生成更连贯的策略运动 。
-   **打乱缓冲区大小**：大型且管理良好的打乱缓冲区对零样本性能至关重要 。
-   **绝对夹爪动作**：尽管在某些情况下原始抓取成功率略低，但因其在失败后的重试行为更佳而被选择优于相对夹爪动作 。

**效果欠佳的方法及其推测原因：**

-   **本体感受输入**：通常会降低性能，可能是由于本体感受信息与目标动作之间存在因果混淆 。
-   **语言模型微调**：未能提升性能；冻结的 t5-base 模型效果最佳。推测原因是数据集中缺乏丰富、多样化的自由格式语言标注（预训练数据中仅 56% 包含语言标注）。
-   **预训练的 ImageNet 编码器 (ResNet)**：在零样本评估中未带来益处，可能与 ResNet 在大型多样化数据集上表现不佳的问题相混淆 。

构建像 Octo 这样复杂的系统涉及许多相互作用的组件和超参数。虽然一些设计选择具有理论依据（例如，使用 Transformer 进行序列建模），但许多具体的实现细节需要通过经验验证。附录 E 详细列出了哪些方法有效，哪些无效，读起来像是一份实验试错的记录（例如，尝试不同的夹爪表示、试图微调语言模型、测试本体感受输入）。一些直观上可能有益的添加（如本体感受输入或语言模型微调）实际上并未奏效，甚至损害了性能，这一事实强调了构建这些系统并非总是直接了当。针对这些负面结果提出的假设（例如，本体感受输入的因果混淆、语言模型微调缺乏丰富的语言数据）为未来的研究提供了宝贵的经验教训。因此，通用机器人策略的开发在很大程度上仍是一项经验性工作。成功不仅依赖于高层次的架构概念，还依赖于对众多“较小”设计选择的广泛实验和仔细的消融研究。那些“（尚）未奏效的方法”与已奏效的方法一样具有信息价值，为未来的工作指明了方向。

# 5. 技术概要与未来展望

Octo 作为一种通用的机器人策略，其核心技术创新在于其架构设计、训练方法论以及对数据的高效利用，共同促成了其在多样化机器人操控任务中的强大能力和适应性。

Octo 的关键技术优势可以概括为：

-   采用Transformer优先的架构 (ViT风格)，能够从大规模、多样化的视觉数据中进行可扩展的学习。
-   通过模块化的输入处理和分块掩码注意力机制，有效处理异构数据，并为灵活的微调（适应新的传感器和动作空间）提供了可能。
-   利用条件扩散动作头生成精确且能够表达多模态分布的连续动作。
-   设计了高效的微调协议，能够利用预训练权重，以最少的数据量快速适应新的领域。
-   强调了大规模、多样化的预训练数据 (Open X-Embodiment) 以及细致的数据处理流程的重要性。

尽管 Octo 在零样本和微调评估中均取得了显著性能，但当前模型仍存在一些技术局限性，这些局限性在很大程度上可归因于训练数据的特性 。例如，当前 Octo 模型在充分处理腕部摄像头信息方面存在困难，这很可能是因为训练数据中仅有 27% 包含腕部摄像头信息 。类似地，在语言指令条件下的策略性能与目标图像条件下的性能之间存在较大差异，这可能与训练数据中语言标注的相对稀缺性有关（仅 56% 的预训练数据包含语言标注）。这些特定模态数据的稀缺性成为了性能瓶颈。即使总体数据集规模庞大（80 万条轨迹），但用于学习特定模态（如腕部摄像头使用或语言理解）的有效数据集规模要小得多。模型无法为它很少见到的模态学习鲁棒的表征或行为。这直接导致了观察到的局限性。因此，未来提升 Octo 或类似模型的工作，需要战略性地解决这些数据缺口，可以通过有针对性的数据收集/标注，或者开发针对代表性不足模态的更高效数据学习技术。这突出表明，如果关键模态的“平衡性”和“覆盖率”不足，“规模”本身并非万能药。

未来的技术增强方向包括：

-   改进对腕部摄像头的支持：可能通过获取更多相关数据或开发更优的传感器融合技术。
-   增强语言条件化能力：可能通过更丰富或更充足的语言标注，或采用跨模态学习方法。
-   超越最优演示的学习：当前模型通过模仿最优演示进行训练。未来工作可以考虑从次优或在线交互数据中学习，这需要采用替代性的学习目标（例如强化学习、离线强化学习）。
-   扩展机器人类型：将应用范围从单臂/双臂操纵器扩展到导航或移动操纵等更广泛的机器人平台 。
